//////////////////////////////////////////////////////////////////////
// JpegPlatform.sc: JPEG Encoder Model for Implementation down to ISS
//////////////////////////////////////////////////////////////////////
// change log:
// 10/03/08 SA	initial C model by Samar Abdi (examined in HW1)
// 10/31/08 RD	"perfect" model (combined/cleaned HW4 submissions,
//		used for estimation in HW5)
// 11/06/08 RD	manually back-annotated timing (HW6)
// 11/11/08 RD	BUG FIX: use 2 buffers for conversion of 2 timestamps
// 11/20/08 RD	added Platform level with explicit I/O blocks
// 11/21/08 RD	change communication channels between quantize, zigzag
//		and huffman to untyped double_handshake (to circumvent
//		limitation in 'scos' and 'sc2c')
// 03/24/10 RD	added two missing fclose() in error conditions
//////////////////////////////////////////////////////////////////////
// SpecC source code generated by SpecC V2.2.1
// Design: jpegencoder
// File:   jpegencoder.sc
// Time:   Thu Oct 30 14:43:16 2008
//////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <sim.sh>
#include <c_typed_queue.sh>	/* make the templates available */
#include <c_typed_double_handshake.sh>

import "c_double_handshake";	// new: untyped double-handshake channel

// some helpful definitions //////////////////////////////////////////

#define TIME_BASE	(1 MICRO_SEC)	// print time in units of micro-seconds
#define QUEUE_SIZE	(25ul)		// ten items max. per queue
#define OQUEUE_SIZE	(2ul)
#define NUMENCODERS 3

#if 1
#define NUMBLOCKS (134*89)
//#define NUMPICS (134*89*9)
//#define NUMBLOCKS (2*89)
#define NUMPICS (134*89*9)
#define HEIGHT 2136 
#define WIDTH 3216
//#define FILELENGTH 20608145
#define FILELENGTH 27477558
#endif

#if 0
#define NUMBLOCKS (134*89)
#define NUMPICS (134*89*16)
#define HEIGHT 2848 
#define WIDTH 4288
#define FILELENGTH 36636689
#endif

#if 0
#define NUMBLOCKS (108*81)
#define NUMPICS (108*81*9)
#define HEIGHT 1944 
#define WIDTH 2592
//#define FILELENGTH 15116561
#define FILELENGTH 20155446
#endif
#define WAITFORENC  172100167
#define WAITFORHUFF 49348944

#define LOOP 0
FILE *fin, *fout;
unsigned char data[FILELENGTH + 100];
unsigned char dataout[FILELENGTH + 100];
unsigned int imageHeight = 0;
unsigned int imageWidth = 0;
int stridex;
int stridey;
int fileHeaderLength;
int numTotalBlocks;
int dataLength;
int zerocnt = 0;
char *fname;

typedef int block[64];	/* define our communication data types */

typedef int blocks[NUMBLOCKS*64];

typedef struct bytes
{
int n;
unsigned char b[1024];
} bytes;

// define the sender/receiver interfaces for the data types
DEFINE_I_TYPED_SENDER(block, block)	// creates interface i_block_sender
DEFINE_I_TYPED_RECEIVER(block, block)	// creates interface i_block_receiver
DEFINE_I_TYPED_TRANCEIVER(block, block)	// creates interface i_block_tranceiver

DEFINE_I_TYPED_SENDER(blocks, blocks)	// creates interface i_blocks_sender
DEFINE_I_TYPED_RECEIVER(blocks, blocks)	// creates interface i_blocks_receiver
DEFINE_I_TYPED_TRANCEIVER(blocks, blocks)	// creates interface i_blocks_tranceiver

DEFINE_I_TYPED_SENDER(bytes, bytes)	// creates interface i_bytes_sender
DEFINE_I_TYPED_RECEIVER(bytes, bytes)	// creates interface i_bytes_receiver
DEFINE_I_TYPED_TRANCEIVER(bytes, bytes)	// creates interface i_bytes_tranceiver

// define the queue and double_handshake channels for the data types
DEFINE_C_TYPED_QUEUE(block, block)	// creates channel c_block_queue
DEFINE_C_TYPED_QUEUE(blocks, blocks)	// creates channel c_blocks_queue
DEFINE_C_TYPED_QUEUE(bytes, bytes)	// creates channel c_bytes_queue
DEFINE_C_TYPED_DOUBLE_HANDSHAKE(blocks, blocks)	// creates channel c_block_double_handshake
DEFINE_C_TYPED_DOUBLE_HANDSHAKE(block, block)	// creates channel c_block_double_handshake
DEFINE_C_TYPED_DOUBLE_HANDSHAKE(bytes, bytes)	// creates channel c_bytes_double_handshake


// behavior declarations /////////////////////////////////////////////

behavior Stimulus(
    i_blocks_sender pout1,
    i_blocks_sender pout2,
    i_blocks_sender pout3
    );

behavior ChenDCT2(
    in int in_block[64],
    out int output_block[64]);

behavior Quantize(
    in int in_block[64],
    out int out_block[64]);	// new

behavior Huffman(
    i_blocks_receiver,	// new
    i_blocks_receiver,
    i_blocks_receiver,
    i_bytes_sender);

behavior DUT(
    i_blocks_receiver,
    i_blocks_receiver,
    i_blocks_receiver,
    i_bytes_sender);

behavior Monitor(
    i_bytes_receiver
    );

behavior DataIn(	// new: virtual HW for data input
    i_blocks_receiver,
    i_blocks_sender);

behavior DataOut(	// new: virtual HW for data output
    i_bytes_receiver,
    i_bytes_sender);

behavior Platform(	// new: platform with DUT and I/O units
    i_blocks_receiver,
    i_blocks_receiver,
    i_blocks_receiver,
    i_bytes_sender);

behavior Main();

// behavior and channel definitions //////////////////////////////////

behavior Stimulus(
    i_blocks_sender pout1,
    i_blocks_sender pout2,
    i_blocks_sender pout3
)
{
	unsigned char *ch;
	unsigned int  yInput[64];
	unsigned int  cbInput[64];
	unsigned int  crInput[64];
	unsigned int  rInput[64]; 
	unsigned int  gInput[64]; 
	unsigned int  bInput[64];
	int output_blocks[NUMENCODERS][NUMBLOCKS*64];
	int bmpoffset;
	int pixellen;

	void ReadRGB(int n)	// read the nth block, assume that the picture has complete blocks (8x8)
	{
		int x, y, i, j, pos;
		unsigned char* ptr;
	
		x = n % stridex * 8;
		y = n / stridex * 8;
		pos = (y * imageWidth + x) * pixellen;
		ptr = &data[fileHeaderLength + pos];

		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{
				bInput[i * 8 + j] = ptr[i * imageWidth * pixellen + j * pixellen];
				gInput[i * 8 + j] = ptr[i * imageWidth * pixellen + j * pixellen + 1];
				rInput[i * 8 + j] = ptr[i * imageWidth * pixellen + j * pixellen + 2];
			}
		}
    	}

    	void RGB2YCC()
    	{
		unsigned int i, j;
		unsigned char r, g, b;
		double y, cb, cr;
	
		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{
				r = rInput[i * 8 + j];
				g = gInput[i * 8 + j];
				b = bInput[i * 8 + j];
	
				y  = (77 * r + 150 * g + 29 * b) /256;
				cb = (-44 * r - 87 * g + 131 * b + 32768) / 256;
				cr = (131 * r - 110 * g - 21 * b + 32768) / 256;

				yInput[i * 8 + j] = (unsigned int) y ;
				cbInput[i * 8 + j] = (unsigned int) cb ;
				crInput[i * 8 + j] = (unsigned int) cr;
			}
		}
    	} 

    	void RGBAVER()
    	{
		int i, j, r, g, b;
		//double y, cb, cr;
	
		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{
				r = rInput[i * 8 + j];
				g = gInput[i * 8 + j];
				b = bInput[i * 8 + j];
	
				yInput[i * 8 + j] = (r + g + b) / 3;
				cbInput[i * 8 + j] = (r + g + b) / 3;
				crInput[i * 8 + j] = (r + g + b) / 3;
			}
		}
    	}

	void ReadPPM()
	{
		fin = fopen(fname, "rb");
		if(fin == NULL)
		{
			printf("Cannot open the file !!!\n");
			exit(0);
		}


		fseek(fin, 0L, SEEK_END);
		dataLength = ftell(fin);
		fseek(fin, 0L, SEEK_SET);


		fread(data, sizeof(char), dataLength, fin);
		
		ch = data;

		ch ++;			/*'P'*/
		ch ++;			/*'6'*/
		ch ++;			/*0x0a*/

		imageWidth = imageWidth * 10 + (*ch - 0x30);
		ch ++;
		imageWidth = imageWidth * 10 + (*ch - 0x30);
		ch ++;
		imageWidth = imageWidth * 10 + (*ch - 0x30);
		ch ++;
		imageWidth = imageWidth * 10 + (*ch - 0x30);
		ch ++;
		stridex = imageWidth >> 3;

		ch ++;	/*0x20*/

		imageHeight = imageHeight * 10 + (*ch - 0x30);
		ch ++;
		imageHeight = imageHeight * 10 + (*ch - 0x30);
		ch ++;
		imageHeight = imageHeight * 10 + (*ch - 0x30);
		ch ++;
		imageHeight = imageHeight * 10 + (*ch - 0x30);
		ch ++;
		stridey = imageHeight >> 3;

		numTotalBlocks = imageWidth * imageHeight / 64;
 
		ch ++;			/*0x0a*/
		ch ++;	/*0x32*/
		ch ++;	/*0x35*/
		ch ++;	/*0x35*/
		ch ++;	/*0x0a*/
	
		fileHeaderLength = 17;
		pixellen = 3;

		printf("imageWidth = %d, imageHeight = %d, numTotalBlocks = %d \n", imageWidth, imageHeight, numTotalBlocks);
	}

	void YCC2RGB()
	{
		int i, j, y, cb, cr;
		double r, g, b;
	
		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{
				y = yInput[i * 8 + j];
				cb = cbInput[i * 8 + j];
				cr = crInput[i * 8 + j];
	
				r = y + 1.371 * (cr - 128);
				g = y - 0.698 * (cr - 128) - 0.336 * (cb - 128);
				b = y + 1.732 * (cb - 128);

				rInput[i * 8 + j] = (int) r;
				gInput[i * 8 + j] = (int) g;
				bInput[i * 8 + j] = (int) b;
			}
		}
	}

	void writeRGBtoFile(int n)
	{
		int x, y, i, j, pos;
		unsigned char* ptr;
	
		x = n % stridex * 8;
		y = n / stridex * 8;

		pos = (y * imageWidth + x) * pixellen;
		ptr = &dataout[fileHeaderLength + pos];
		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{	
				ptr[i * imageWidth * pixellen + j * pixellen] =  rInput[i * 8 + j];
				ptr[i * imageWidth * pixellen + j * pixellen + 1] = gInput[i * 8 + j];
				ptr[i * imageWidth * pixellen + j * pixellen + 2] = bInput[i * 8 + j];
			}
		}
	}


	void writeYCCtoFile(int n)
	{
		int x, y, i, j, pos;
		unsigned char* ptr;
	
		x = n % stridex * 8;
		y = n / stridex * 8;

		pos = (y * imageWidth + x) * 3;

		ptr = &dataout[fileHeaderLength + pos];
       
		for(i = 0; i < 8; i ++)
		{
			for(j = 0; j < 8; j ++)
			{
				ptr[i * imageWidth * 3 + j * 3] = 0;
				ptr[i * imageWidth * 3 + j * 3 + 1] = 0;
				ptr[i * imageWidth * 3 + j * 3 + 2] = 255;
			}
		}
	}

	void ReadBMP()
	{
		int i;
		fin = fopen(fname, "rb");
		if(fin == NULL)
		{
			printf("Cannot open the file !!!\n");
			exit(0);
		}


		fseek(fin, 0L, SEEK_END);
		dataLength = ftell(fin);
		fseek(fin, 0L, SEEK_SET);


		fread(data, sizeof(char), dataLength, fin);
		
		ch = data;

		ch ++;			/*'B'*/
		ch ++;			/*'M'*/

		ch += 8;

		bmpoffset = 0;
		for(i = 3; i >= 0; i --){
			bmpoffset = (bmpoffset << 8) | ch[i];
		}

		ch += 8;

		imageWidth = 0;
		for(i = 3; i >= 0; i --){
			imageWidth = (imageWidth << 8) | ch[i];
		}
		stridex = imageWidth >> 3;
		ch += 4;

		imageHeight = 0;
		for(i = 3; i >= 0; i --){
			imageHeight = (imageHeight << 8) | ch[i];
		}
		if((int)imageHeight < 0){
			imageHeight = -((int)imageHeight);
		}
		stridey = imageHeight >> 3;
		ch += 6;

		pixellen = 0;
		for(i = 1; i >= 0; i --){
			pixellen = (pixellen << 8) | ch[i];
		}
		pixellen >>= 3;

		numTotalBlocks = imageWidth * imageHeight / 64;
		fileHeaderLength = bmpoffset;

		printf("imageWidth = %d, imageHeight = %d, numTotalBlocks = %d, fileHeaderLength = %d \n"
		, imageWidth, imageHeight, numTotalBlocks, fileHeaderLength);
	}

	void main(void)
        {   
		int iter = 0;
		//sim_time t;
		//sim_time_string buf;
		//int i, j, k, h, m;
				

		//ReadPPM();
		//fout = fopen("red.ppm", "wb");
		//memcpy(dataout, data, sizeof(char) * 17);
		ReadBMP();
		

		while(iter < NUMPICS){
	 		ReadRGB(iter);
			RGB2YCC();
			
			memcpy(&output_blocks[0][iter%NUMBLOCKS*64], yInput, sizeof(int) * 64);
			memcpy(&output_blocks[1][iter%NUMBLOCKS*64], cbInput, sizeof(int) * 64);
			memcpy(&output_blocks[2][iter%NUMBLOCKS*64], crInput, sizeof(int) * 64);

			iter ++;
			if(iter % NUMBLOCKS  == 0){
				pout1.send(output_blocks[0]);
				pout2.send(output_blocks[1]);
				pout3.send(output_blocks[2]);	
			}
		}
	}
};

behavior ChenDCT1(
    in int in_blocks[NUMBLOCKS*64],
    out int output_block[64])
{
    int iter = 0;

    void main(void)
    {   
	//static int iter = 0;
	int aptr;
	int i;
	int tval;
	int a0;
	int a1;
	int a2;
	int a3;
	int b0;
	int b1;
	int b2;
	int b3;
	int c0;
	int c1;
	int c2;
	int c3;
	int v0;
	int v1;
	int v2;
	int v3;
	int v4;
	int v5;
	int v6;
	int v7;
	//int in_blocks[NUMBLOCKS*64];
	int *in_block;
	int out_block[64];
	//int f = 1.2;
	//while(1)
	{   

	  // if(iter % NUMBLOCKS == 0){
	  //  Port1.receive( &in_blocks);
	  //  waitfor WAITFORENC;
	  // }
	   in_block = &in_blocks[(iter%NUMBLOCKS)*64];
	  // waitfor WAITFORENC;
	  // printf("this is dct1 %d\n", iter);


	    if (iter % 2 == 1)
	    {   
		//Port2.send(in_block);
		for(i = 0; i < 64; i ++)
		{
			output_block[i] = in_block[i];
		}
		iter++ ;
		 
	    }
	    else 
	    {   
             
		for(i = 0; i < 64; i++ )
		{   
		    tval = in_block[i];
		    in_block[i] = tval - 128;
		}
              
		for(i = 0; i < 8; i++ )
		{   
		    aptr = i;
		    v0 = in_block[aptr];
		    aptr += 8;
		    v1 = in_block[aptr];
		    aptr += 8;
		    v2 = in_block[aptr];
		    aptr += 8;
		    v3 = in_block[aptr];
		    aptr += 8;
		    v4 = in_block[aptr];
		    aptr += 8;
		    v5 = in_block[aptr];
		    aptr += 8;
		    v6 = in_block[aptr];
		    aptr += 8;
		    v7 = in_block[aptr];
		    a0 = (((v0 + v7)) << (2));
		    c3 = (((v0 - v7)) << (2));
		    a1 = (((v1 + v6)) << (2));
		    c2 = (((v1 - v6)) << (2));
		    a2 = (((v2 + v5)) << (2));
		    c1 = (((v2 - v5)) << (2));
		    a3 = (((v3 + v4)) << (2));
		    c0 = (((v3 - v4)) << (2));
		    b0 = a0 + a3;
		    b1 = a1 + a2;
		    b2 = a1 - a2;
		    b3 = a0 - a3;
		    out_block[i] = (((362l * (b0 + b1))) >> (9));
		    out_block[i + 32] = (((362l * (b0 - b1))) >> (9));
		    out_block[i + 16] = ((((196l * b2) + (473l * b3))) >> 
			(9));
		    out_block[i + 48] = ((((196l * b3) - (473l * b2))) >> 
			(9));
		    b0 = (((362l * (c2 - c1))) >> (9));
		    b1 = (((362l * (c2 + c1))) >> (9));
		    a0 = c0 + b0;
		    a1 = c0 - b0;
		    a2 = c3 - b1;
		    a3 = c3 + b1;
		    out_block[i + 8] = ((((100l * a0) + (502l * a3))) >> 
			(9));
		    out_block[i + 24] = ((((426l * a2) - (284l * a1))) >> 
			(9));
		    out_block[i + 40] = ((((426l * a1) + (284l * a2))) >> 
			(9));
		    out_block[i + 56] = ((((100l * a3) - (502l * a0))) >> 
			(9));
		}
		for(i = 0; i < 8; i++ )
		{   
		    aptr = ((i) << (3));
		    v0 = out_block[aptr];
		    aptr++ ;
		    v1 = out_block[aptr];
		    aptr++ ;
		    v2 = out_block[aptr];
		    aptr++ ;
		    v3 = out_block[aptr];
		    aptr++ ;
		    v4 = out_block[aptr];
		    aptr++ ;
		    v5 = out_block[aptr];
		    aptr++ ;
		    v6 = out_block[aptr];
		    aptr++ ;
		    v7 = out_block[aptr];
		    c3 = (((v0 - v7)) >> (1));
		    a0 = (((v0 + v7)) >> (1));
		    c2 = (((v1 - v6)) >> (1));
		    a1 = (((v1 + v6)) >> (1));
		    c1 = (((v2 - v5)) >> (1));
		    a2 = (((v2 + v5)) >> (1));
		    c0 = (((v3 - v4)) >> (1));
		    a3 = (((v3 + v4)) >> (1));
		    b0 = a0 + a3;
		    b1 = a1 + a2;
		    b2 = a1 - a2;
		    b3 = a0 - a3;
		    aptr = ((i) << (3));
		    out_block[aptr] = (((362l * (b0 + b1))) >> (9));
		    out_block[aptr + 4] = (((362l * (b0 - b1))) >> (9));
		    out_block[aptr + 2] = ((((196l * b2) + (473l * b3))) >> 
			(9));
		    out_block[aptr + 6] = ((((196l * b3) - (473l * b2))) >> 
			(9));
		    b0 = (((362l * (c2 - c1))) >> (9));
		    b1 = (((362l * (c2 + c1))) >> (9));
		    a0 = c0 + b0;
		    a1 = c0 - b0;
		    a2 = c3 - b1;
		    a3 = c3 + b1;
		    out_block[aptr + 1] = ((((100l * a0) + (502l * a3))) >> 
			(9));
		    out_block[aptr + 3] = ((((426l * a2) - (284l * a1))) >> 
			(9));
		    out_block[aptr + 5] = ((((426l * a1) + (284l * a2))) >> 
			(9));
		    out_block[aptr + 7] = ((((100l * a3) - (502l * a0))) >> 
			(9));
		}
		for(i = 0; i < 64; i++ )
		{   
		    tval = out_block[i];
		    tval = (((tval < 0) ? (tval - 4) : (tval + 4)) / 8);
		    if (tval <  -1023)
		    {   
			tval =  -1023;
		    }
		    else 
			if (tval > 1023)
			{   
			    tval = 1023;
			}
		    out_block[i] = tval;
		}
		iter++ ;
		for(i = 0; i < 64; i ++)
		{
			output_block[i] = out_block[i];
		}

		
		//Port2.send(out_block);
	    }
	}
    }
};

behavior ChenDCT2(
    in int input_block[64],
    out int output_block[64])
{
    int iter = 0;
    void main(void)
    {   
	//static int iter = 0;
	int aptr;
	int i;
	int tval;
	int a0;
	int a1;
	int a2;
	int a3;
	int b0;
	int b1;
	int b2;
	int b3;
	int c0;
	int c1;
	int c2;
	int c3;
	int v0;
	int v1;
	int v2;
	int v3;
	int v4;
	int v5;
	int v6;
	int v7;
	int in_block[64];
	int out_block[64];

	//while(1)
	{   
	//    Port1.receive( &in_block);
	 //   waitfor 10411200000ull/180;
	//printf("this is dct2 iter= %d\n", iter);
	    for(i = 0; i < 64; i ++)
		{
			in_block[i] = input_block[i];
		}
	
	    if (iter % 2 == 0)
	    {   
		//Port2.send(in_block);
		for(i = 0; i < 64; i ++)
		{
			output_block[i] = in_block[i];
		}
		iter++ ;
	    }
	    else 
	    {   
		for(i = 0; i < 64; i++ )
		{   
		    tval = in_block[i];
		    in_block[i] = tval - 128;
		}
		for(i = 0; i < 8; i++ )
		{   
		    aptr = i;
		    v0 = in_block[aptr];
		    aptr += 8;
		    v1 = in_block[aptr];
		    aptr += 8;
		    v2 = in_block[aptr];
		    aptr += 8;
		    v3 = in_block[aptr];
		    aptr += 8;
		    v4 = in_block[aptr];
		    aptr += 8;
		    v5 = in_block[aptr];
		    aptr += 8;
		    v6 = in_block[aptr];
		    aptr += 8;
		    v7 = in_block[aptr];
		    a0 = (((v0 + v7)) << (2));
		    c3 = (((v0 - v7)) << (2));
		    a1 = (((v1 + v6)) << (2));
		    c2 = (((v1 - v6)) << (2));
		    a2 = (((v2 + v5)) << (2));
		    c1 = (((v2 - v5)) << (2));
		    a3 = (((v3 + v4)) << (2));
		    c0 = (((v3 - v4)) << (2));
		    b0 = a0 + a3;
		    b1 = a1 + a2;
		    b2 = a1 - a2;
		    b3 = a0 - a3;
		    out_block[i] = (((362l * (b0 + b1))) >> (9));
		    out_block[i + 32] = (((362l * (b0 - b1))) >> (9));
		    out_block[i + 16] = ((((196l * b2) + (473l * b3))) >> 
			(9));
		    out_block[i + 48] = ((((196l * b3) - (473l * b2))) >> 
			(9));
		    b0 = (((362l * (c2 - c1))) >> (9));
		    b1 = (((362l * (c2 + c1))) >> (9));
		    a0 = c0 + b0;
		    a1 = c0 - b0;
		    a2 = c3 - b1;
		    a3 = c3 + b1;
		    out_block[i + 8] = ((((100l * a0) + (502l * a3))) >> 
			(9));
		    out_block[i + 24] = ((((426l * a2) - (284l * a1))) >> 
			(9));
		    out_block[i + 40] = ((((426l * a1) + (284l * a2))) >> 
			(9));
		    out_block[i + 56] = ((((100l * a3) - (502l * a0))) >> 
			(9));
		}
		for(i = 0; i < 8; i++ )
		{   
		    aptr = ((i) << (3));
		    v0 = out_block[aptr];
		    aptr++ ;
		    v1 = out_block[aptr];
		    aptr++ ;
		    v2 = out_block[aptr];
		    aptr++ ;
		    v3 = out_block[aptr];
		    aptr++ ;
		    v4 = out_block[aptr];
		    aptr++ ;
		    v5 = out_block[aptr];
		    aptr++ ;
		    v6 = out_block[aptr];
		    aptr++ ;
		    v7 = out_block[aptr];
		    c3 = (((v0 - v7)) >> (1));
		    a0 = (((v0 + v7)) >> (1));
		    c2 = (((v1 - v6)) >> (1));
		    a1 = (((v1 + v6)) >> (1));
		    c1 = (((v2 - v5)) >> (1));
		    a2 = (((v2 + v5)) >> (1));
		    c0 = (((v3 - v4)) >> (1));
		    a3 = (((v3 + v4)) >> (1));
		    b0 = a0 + a3;
		    b1 = a1 + a2;
		    b2 = a1 - a2;
		    b3 = a0 - a3;
		    aptr = ((i) << (3));
		    out_block[aptr] = (((362l * (b0 + b1))) >> (9));
		    out_block[aptr + 4] = (((362l * (b0 - b1))) >> (9));
		    out_block[aptr + 2] = ((((196l * b2) + (473l * b3))) >> 
			(9));
		    out_block[aptr + 6] = ((((196l * b3) - (473l * b2))) >> 
			(9));
		    b0 = (((362l * (c2 - c1))) >> (9));
		    b1 = (((362l * (c2 + c1))) >> (9));
		    a0 = c0 + b0;
		    a1 = c0 - b0;
		    a2 = c3 - b1;
		    a3 = c3 + b1;
		    out_block[aptr + 1] = ((((100l * a0) + (502l * a3))) >> 
			(9));
		    out_block[aptr + 3] = ((((426l * a2) - (284l * a1))) >> 
			(9));
		    out_block[aptr + 5] = ((((426l * a1) + (284l * a2))) >> 
			(9));
		    out_block[aptr + 7] = ((((100l * a3) - (502l * a0))) >> 
			(9));
		}
		for(i = 0; i < 64; i++ )
		{   
		    tval = out_block[i];
		    tval = (((tval < 0) ? (tval - 4) : (tval + 4)) / 8);
		    if (tval <  -1023)
		    {   
			tval =  -1023;
		    }
		    else 
			if (tval > 1023)
			{   
			    tval = 1023;
			}
		    out_block[i] = tval;
		}
		//Port2.send(out_block);
		for(i = 0; i < 64; i ++)
		{
			output_block[i] = out_block[i];
		}
		iter++ ;
	    }
	}
    }
};

behavior Quantize(
    in int in_block[64],
    out int out_block[64])	// new
{
    int LuminanceQuantization[] = 
    { 16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,
      69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,
      64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,
      103,99 };

    void main(void)
    {   
	int i;
	int m;
	int o;
	int q;
	//int in_block[64];
	//int out_block[64];

	//while(1)
	{   
	//    Port1.receive( &in_block);
	 //   waitfor 7839030000ull/180;
	//	printf("this is quant \n");
	    q = LuminanceQuantization[0];
	    for(i = 0; i < 64; i++ )
	    {   
		m = in_block[i];
		if (m > 0)
		{   
		    o = (m + q / 2) / q;
		}
		else 
		{   
		    o = (m - q / 2) / q;
		}
		if (i < 63)
		{   
		    q = LuminanceQuantization[i + 1];
		}
		out_block[i] = o;
	    }
	    //Port2.send(&out_block, sizeof(out_block));	// new
	}
    }
};

behavior CHROM_Quantize(
    in int in_block[64],
    out int out_block[64])	// new
{
    int CHROM_Quantization[] = 
     {
            17,  18,  24,  47,  99,  99,  99,  99,
            18,  21,  26,  66,  99,  99,  99,  99,
            24,  26,  56,  99,  99,  99,  99,  99,
            47,  66,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99
        };

    void main(void)
    {   
	int i;
	int m;
	int o;
	int q;
	//int in_block[64];
	//int out_block[64];

	//while(1)
	{   
	//    Port1.receive( &in_block);
	 //   waitfor 7839030000ull/180;
	//	printf("this is quant \n");
	    q = CHROM_Quantization[0];
	    for(i = 0; i < 64; i++ )
	    {   
		m = in_block[i];
		if (m > 0)
		{   
		    o = (m + q / 2) / q;
		}
		else 
		{   
		    o = (m - q / 2) / q;
		}
		if (i < 63)
		{   
		    q = CHROM_Quantization[i + 1];
		}
		out_block[i] = o;
	    }
	    //Port2.send(&out_block, sizeof(out_block));	// new
	}
    }
};

behavior Zigzag(
    in int in_block[64],	// new
    //i_block_sender Port2,
    //i_blocks_sender  Port2
    out int out_blocks[NUMBLOCKS*64]
   )	
{
    int ZigzagIndex[] = 
    { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,
      11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,
      60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };
    int IZigzagIndex[] = 
    { 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,
      27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,
      44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63 };

    int iter = 0;
   // int out_blocks[NUMBLOCKS*64];

    void main(void)
    {   
	int i;
	int z;
	//int in_block[64];
	//int out_block[64];

	//while(1)
	{   
	    for(i = 0; i < 64; i++ )
	    {   
		z = ZigzagIndex[i];
		out_blocks[z + (iter % NUMBLOCKS) * 64] = in_block[i];
	    }

     	   iter ++;
	}
    }
};

behavior Huffman(
      i_blocks_receiver Port1,	// new
      i_blocks_receiver Port2,
      i_blocks_receiver Port3,
      i_bytes_sender PortOut)
{
    int ACXhuff_bits[36];
    int ACXhuff_huffval[257];
    int DCXhuff_bits[36];
    int DCXhuff_huffval[257];
    int ACEhuff_ehufco[257];
    int ACEhuff_ehufsi[257];
    int DCEhuff_ehufco[257];
    int DCEhuff_ehufsi[257];
    int huffsize[257];
    int huffcode[257];
    unsigned char ofp[2000*NUMPICS];
    int *input;
    int lastp;

    int CHROM_ACXhuff_bits[36];
    int CHROM_ACXhuff_huffval[257];
    int CHROM_DCXhuff_bits[36];
    int CHROM_DCXhuff_huffval[257];
    int CHROM_ACEhuff_ehufco[257];
    int CHROM_ACEhuff_ehufsi[257];
    int CHROM_DCEhuff_ehufco[257];
    int CHROM_DCEhuff_ehufsi[257];
    int CHROM_huffsize[257];
    int CHROM_huffcode[257];
    int CHROM_lastp;


    int LastDC = 0;
    int LastDC_Cb = 0;
    int LastDC_Cr = 0;
    int ofp_ptr = 0;
    int ofp_ptr_pre = 0;
    int imageheight;
    int imagewidth;
    int csize[] = 
    { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
      6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
      7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
      8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8 };
    int LuminanceDCBits[] = 
    { 0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0 };
    int LuminanceDCValues[] = 
    { 0,1,2,3,4,5,6,7,8,9,10,11 };
    int LuminanceACBits[] = 
    { 0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125 };
    int LuminanceACValues[] = 
    { 1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,
      8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,
      26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,
      83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,
      118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,
      149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,
      179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,
      202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,
      231,232,233,234,241,242,243,244,245,246,247,248,249,250 };

int CHROM_DCBits[] = 
    { 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
    int CHROM_DCValues[] = 
    { 0,1,2,3,4,5,6,7,8,9,10,11 };
    int CHROM_ACBits[] = 
    { 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
    int CHROM_ACValues[] = 
    {
            0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
            0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
            0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
            0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
            0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
            0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
            0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
            0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
            0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
            0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
            0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
            0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
            0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
            0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
            0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
            0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
            0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
            0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
            0xf9, 0xfa
        };


    unsigned int lmask[] = 
    { 0u,1u,3u,7u,15u,31u,63u,127u,255u,511u,1023u,2047u,4095u,8191u,16383u,
      32767u,65535u };
    int IZgzgIndex[] = 
    { 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,
      27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,
      44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63 };
    int LumiQuant[] = 
    { 16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,
      69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,
      64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,
      103,99 };
   int CHROM_Quant[] =  {
            17,  18,  24,  47,  99,  99,  99,  99,
            18,  21,  26,  66,  99,  99,  99,  99,
            24,  26,  56,  99,  99,  99,  99,  99,
            47,  66,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99,
            99,  99,  99,  99,  99,  99,  99,  99
        };
   
     int in_blocks[NUMENCODERS][NUMBLOCKS*64];
     int f = 1.2;
    int iter = 0;
    
    
    
    void SizeTable_DC()
    {   
	int i;
	int j;
	int p;

	p = 0;
	for(i = 1; i < 17; i++ )
	{   
	    for(j = 1; j <= DCXhuff_bits[i]; j++ )
	    {   
		huffsize[p++ ] = i;
	    }
	}
	huffsize[p] = 0;
	lastp = p;
    }

    void SizeTable_AC()
    {   
	int i;
	int j;
	int p;

	p = 0;
	for(i = 1; i < 17; i++ )
	{   
	    for(j = 1; j <= ACXhuff_bits[i]; j++ )
	    {   
		huffsize[p++ ] = i;
	    }
	}
	huffsize[p] = 0;
	lastp = p;
    }

    void CodeTable()
    {   
	int code;
	int p;
	int size;
	int skip = 0;

	p = 0;
	code = 0;
	size = huffsize[0];
	while(0 == skip)
	{   
	    do 
	    {   
		huffcode[p++ ] = code++ ;
	    }
	    while((huffsize[p] == size) && (p < 257));
	    if (0 == huffsize[p])
	    {   
		skip = 1;
	    }
	    if ( !skip)
	    {   
		do 
		{   
		    code <<= 1;
		    size++ ;
		}
		while(huffsize[p] != size);
	    }
	}
    }

    void OrderCodes_DC()
    {   
	int Index;
	int p;

	for(p = 0; p < lastp; p++ )
	{   
	    Index = DCXhuff_huffval[p];
	    DCEhuff_ehufco[Index] = huffcode[p];
	    DCEhuff_ehufsi[Index] = huffsize[p];
	}
    }

    void SpecifiedHuffman_DC()
    {   
	int i;
	int accum = 0;
	int tmp;

	for(i = 0; i < 16; i++ )
	{   
	    tmp = LuminanceDCBits[i];
	    accum += tmp;
	    DCXhuff_bits[i + 1] = tmp;
	}
	for(i = 0; i < accum; i++ )
	{   
	    DCXhuff_huffval[i] = LuminanceDCValues[i];
	}
	SizeTable_DC();
	CodeTable();
	OrderCodes_DC();
    }

    void OrderCodes_AC()
    {   
	int Index;
	int p;

	for(p = 0; p < lastp; p++ )
	{   
	    Index = ACXhuff_huffval[p];
	    ACEhuff_ehufco[Index] = huffcode[p];
	    ACEhuff_ehufsi[Index] = huffsize[p];
	}
    }

    void SpecifiedHuffman_AC()
    {   
	int i;
	int accum = 0;
	int tmp;

	for(i = 0; i < 16; i++ )
	{   
	    tmp = LuminanceACBits[i];
	    accum += tmp;
	    ACXhuff_bits[i + 1] = tmp;
	}
	for(i = 0; i < accum; i++ )
	{   
	    ACXhuff_huffval[i] = LuminanceACValues[i];
	}
	SizeTable_AC();
	CodeTable();
	OrderCodes_AC();
    }


void CHROM_SizeTable_DC()
    {   
	int i;
	int j;
	int p;

	p = 0;
	for(i = 1; i < 17; i++ )
	{   
	    for(j = 1; j <= CHROM_DCXhuff_bits[i]; j++ )
	    {   
		CHROM_huffsize[p++ ] = i;
	    }
	}
	CHROM_huffsize[p] = 0;
	CHROM_lastp = p;
    }

    void CHROM_SizeTable_AC()
    {   
	int i;
	int j;
	int p;

	p = 0;
	for(i = 1; i < 17; i++ )
	{   
	    for(j = 1; j <= CHROM_ACXhuff_bits[i]; j++ )
	    {   
		CHROM_huffsize[p++ ] = i;
	    }
	}
	CHROM_huffsize[p] = 0;
	CHROM_lastp = p;
    }

    void CHROM_CodeTable()
    {   
	int code;
	int p;
	int size;
	int skip = 0;

	p = 0;
	code = 0;
	size = CHROM_huffsize[0];
	while(0 == skip)
	{   
	    do 
	    {   
		CHROM_huffcode[p++ ] = code++ ;
	    }
	    while((CHROM_huffsize[p] == size) && (p < 257));
	    if (0 == CHROM_huffsize[p])
	    {   
		skip = 1;
	    }
	    if ( !skip)
	    {   
		do 
		{   
		    code <<= 1;
		    size++ ;
		}
		while(CHROM_huffsize[p] != size);
	    }
	}
    }

    void CHROM_OrderCodes_DC()
    {   
	int Index;
	int p;

	for(p = 0; p < CHROM_lastp; p++ )
	{   
	    Index = CHROM_DCXhuff_huffval[p];
	    CHROM_DCEhuff_ehufco[Index] = CHROM_huffcode[p];
	    CHROM_DCEhuff_ehufsi[Index] = CHROM_huffsize[p];
	}
    }

    void CHROM_SpecifiedHuffman_DC()
    {   
	int i;
	int accum = 0;
	int tmp;

	for(i = 0; i < 16; i++ )
	{   
	    tmp = CHROM_DCBits[i];
	    accum += tmp;
	    CHROM_DCXhuff_bits[i + 1] = tmp;
	}
	for(i = 0; i < accum; i++ )
	{   
	    CHROM_DCXhuff_huffval[i] = CHROM_DCValues[i];
	}
	CHROM_SizeTable_DC();
	CHROM_CodeTable();
	CHROM_OrderCodes_DC();
    }

    void CHROM_OrderCodes_AC()
    {   
	int Index;
	int p;

	for(p = 0; p < CHROM_lastp; p++ )
	{   
	    Index = CHROM_ACXhuff_huffval[p];
	    CHROM_ACEhuff_ehufco[Index] = CHROM_huffcode[p];
	    CHROM_ACEhuff_ehufsi[Index] = CHROM_huffsize[p];
	}
    }

    void CHROM_SpecifiedHuffman_AC()
    {   
	int i;
	int accum = 0;
	int tmp;

	for(i = 0; i < 16; i++ )
	{   
	    tmp = CHROM_ACBits[i];
	    accum += tmp;
	    CHROM_ACXhuff_bits[i + 1] = tmp;
	}
	for(i = 0; i < accum; i++ )
	{   
	    CHROM_ACXhuff_huffval[i] = CHROM_ACValues[i];
	}
	CHROM_SizeTable_AC();
	CHROM_CodeTable();
	CHROM_OrderCodes_AC();
    }




    void JpegDefaultHuffman()
    {   
	SpecifiedHuffman_DC();
	SpecifiedHuffman_AC();
	CHROM_SpecifiedHuffman_DC();
	CHROM_SpecifiedHuffman_AC();
    }

    int WriteBits(int n, int code)
    {   
	static unsigned char write_byte = ((unsigned char)'\000');
	static int left_bits = 8;
	int p;
	int temp;

	temp = ofp_ptr;
	if (n < 0)
	{   
	    if (left_bits < 8)
	    {   
		n = left_bits;
		ofp[temp++ ] = write_byte;
		if (write_byte == 255)
		    ofp[temp++ ] = 0;
		write_byte = 0;
		left_bits = 8;
	    }
	    else 
		n = 0;
	}
	else 
	{   
	    code &= lmask[n];
	    p = n - left_bits;
	    if (n == left_bits)
	    {   
		write_byte |= code;
		ofp[temp++ ] = write_byte;
		if (write_byte == 255)
		    ofp[temp++ ] = 0;
		write_byte = 0;
		left_bits = 8;
	    }
	    else 
		if (n > left_bits)
		{   
		    write_byte |= (code >> p);
		    ofp[temp++ ] = write_byte;
		    if (write_byte == 255)
			ofp[temp++ ] = 0;
		    if (p > 8)
		    {   
			write_byte = (255 & (code >> (p - 8)));
			ofp[temp++ ] = write_byte;
			if (write_byte == 255)
			    ofp[temp++ ] = 0;
			p -= 8;
		    }
		    write_byte = (code & lmask[p]) << (8 - p);
		    left_bits = 8 - p;
		}
		else 
		{   
		    write_byte |= (code <<  -p);
		    left_bits -= n;
		}
	}
	ofp_ptr = temp;
	return n;
    }

    void EncodeHuffman_DC(int value)
    {   
	if (DCEhuff_ehufsi[value])
	{   
	    WriteBits(DCEhuff_ehufsi[value], DCEhuff_ehufco[value]);
	}
    }

    void EncodeDC()
    {   
	int cofac;
	int diff;
	int s;

	diff = input[0] - LastDC;
	LastDC = input[0];
	if (diff < 0)
	    cofac =  -diff;
	else 
	    cofac = diff;
	if (cofac < 256)
	{   
	    s = csize[cofac];
	}
	else 
	{   
	    cofac = cofac >> 8;
	    s = csize[cofac] + 8;
	}
	EncodeHuffman_DC(s);
	if (diff < 0)
	{   
	    diff-- ;
	}
	WriteBits(s, diff);
    }
   
    void CHROM_EncodeHuffman_DC(int value)
    {   
	if (CHROM_DCEhuff_ehufsi[value])
	{   
	    WriteBits(CHROM_DCEhuff_ehufsi[value], CHROM_DCEhuff_ehufco[value]);
	}
    }


    void EncodeDC_Cb()
    {   
	int cofac;
	int diff;
	int s;

	diff = input[0] - LastDC_Cb;
	LastDC_Cb = input[0];
	if (diff < 0)
	    cofac =  -diff;
	else 
	    cofac = diff;
	if (cofac < 256)
	{   
	    s = csize[cofac];
	}
	else 
	{   
	    cofac = cofac >> 8;
	    s = csize[cofac] + 8;
	}
	CHROM_EncodeHuffman_DC(s);
	if (diff < 0)
	{   
	    diff-- ;
	}
	WriteBits(s, diff);
    }
   
    void EncodeDC_Cr()
    {   
	int cofac;
	int diff;
	int s;

	diff = input[0] - LastDC_Cr;
	LastDC_Cr = input[0];
	if (diff < 0)
	    cofac =  -diff;
	else 
	    cofac = diff;
	if (cofac < 256)
	{   
	    s = csize[cofac];
	}
	else 
	{   
	    cofac = cofac >> 8;
	    s = csize[cofac] + 8;
	}
	CHROM_EncodeHuffman_DC(s);
	if (diff < 0)
	{   
	    diff-- ;
	}
	WriteBits(s, diff);
    }

    void EncodeHuffman_AC(int value)
    {   
	if (ACEhuff_ehufsi[value])
	{   
	    WriteBits(ACEhuff_ehufsi[value], ACEhuff_ehufco[value]);
	}
    }
   
    void CHROM_EncodeHuffman_AC(int value)
    {   
	if (CHROM_ACEhuff_ehufsi[value])
	{   
	    WriteBits(CHROM_ACEhuff_ehufsi[value], CHROM_ACEhuff_ehufco[value]);
	}
    }

    void EncodeAC()
    {   
	int cofac;
	int i;
	int k;
	int r;
	int ssss;

	r = 0;
	for(k = 1; k < 64; k++ )
	{   
	    if (input[k] < 0)
		cofac =  -input[k];
	    else 
		cofac = input[k];
	    if (cofac < 256)
		ssss = csize[cofac];
	    else 
	    {   
		cofac = cofac >> 8;
		ssss = csize[cofac] + 8;
	    }
	    if (input[k] == 0)
	    {   
		if (k == 63)
		{   
		    EncodeHuffman_AC(0);
		    k = 64;
		}
		else 
		    r++ ;
	    }
	    else 
	    {   
		while(r > 15)
		{   
		    EncodeHuffman_AC(240);
		    r -= 16;
		}
		i = 16 * r + ssss;
		r = 0;
		EncodeHuffman_AC(i);
		if (input[k] < 0)
		    WriteBits(ssss, input[k] - 1);
		else 
		    WriteBits(ssss, input[k]);
	    }
	}
    }

    void CHROM_EncodeAC()
    {   
	int cofac;
	int i;
	int k;
	int r;
	int ssss;

	r = 0;
	for(k = 1; k < 64; k++ )
	{   
	    if (input[k] < 0)
		cofac =  -input[k];
	    else 
		cofac = input[k];
	    if (cofac < 256)
		ssss = csize[cofac];
	    else 
	    {   
		cofac = cofac >> 8;
		ssss = csize[cofac] + 8;
	    }
	    if (input[k] == 0)
	    {   
		if (k == 63)
		{   
		    CHROM_EncodeHuffman_AC(0);
		    k = 64;
		}
		else 
		    r++ ;
	    }
	    else 
	    {   
		while(r > 15)
		{   
		    CHROM_EncodeHuffman_AC(240);
		    r -= 16;
		}
		i = 16 * r + ssss;
		r = 0;
		CHROM_EncodeHuffman_AC(i);
		if (input[k] < 0)
		    WriteBits(ssss, input[k] - 1);
		else 
		    WriteBits(ssss, input[k]);
	    }
	}
    }

    int WriteWord(int code)
    {   
	int temp;

	temp = ofp_ptr;
	ofp[temp] = (code >> 8);
	temp++ ;
	ofp[temp] = (code & 255);
	temp++ ;
	ofp_ptr = temp;
	return 2;
    }

    int WriteByte(int code)
    {   
	int temp;

	temp = ofp_ptr;
	ofp[temp++ ] = code;
	ofp_ptr = temp;
	return code;
    }

    void WriteMarker(int m)
    {   
	ofp[ofp_ptr++ ] = 255;
	ofp[ofp_ptr++ ] = m;
    }

    void WriteAPP0()
    {   
#if 0
	WriteMarker(224);
	WriteWord(16);
	ofp[ofp_ptr++ ] = 'J';
	ofp[ofp_ptr++ ] = 'F';
	ofp[ofp_ptr++ ] = 'I';
	ofp[ofp_ptr++ ] = 'F';
	ofp[ofp_ptr++ ] = '\000';
	WriteWord(258);
	WriteByte(2);
	WriteWord(29);
	WriteWord(29);
	WriteWord(0);
#endif

	WriteMarker(224);
	WriteWord(16);
	WriteByte((unsigned int)'J');
	WriteByte((unsigned int)'F');
	WriteByte((unsigned int)'I');
	WriteByte((unsigned int)'F');
	WriteByte(0);
	WriteByte(1);
	WriteByte(1);
	WriteByte(0);
	WriteWord(1);
	WriteWord(1);
	WriteByte(0);
	WriteByte(0);
    }

    void WriteDQT()
    {   
#if 0
	int Pq = 0;
	int i;
	int end_p;
	int start_p;

	WriteMarker(219);
	start_p = ofp_ptr;
	WriteWord(67);
	for(i = 0; i < 64; i++ )
	{   
	    if (LumiQuant[i] > 255)
		Pq = 16;
	}
	WriteByte(Pq | 0);
	for(i = 0; i < 64; i++ )
	{   
	    if (Pq)
		WriteWord(LumiQuant[IZgzgIndex[i]]);
	    else 
		WriteByte(LumiQuant[IZgzgIndex[i]]);
	}
	end_p = ofp_ptr;
	ofp_ptr = start_p;
	WriteWord(end_p - start_p);
	ofp_ptr = end_p;
#endif

	int Pq = 0;
	int i;
//	int end_p;
	int start_p;
	
	WriteMarker(219);
	start_p = ofp_ptr;
	WriteWord(132);
	
	for(i = 0; i < 64; i++ )
	{   
	    if (LumiQuant[i] > 255)
		Pq = 16;
	}
		
        WriteByte(0|Pq);
	for(i = 0; i < 64; i++ )
	{   
		if(Pq){
			WriteWord(LumiQuant[IZgzgIndex[i]]);
		}
		else{
			WriteByte(LumiQuant[IZgzgIndex[i]]);
		}
	}

	Pq = 0;
	for(i = 0; i < 64; i++ )
	{   
	    if (CHROM_Quant[i] > 255)
		Pq = 16;
	}
	
        WriteByte(0x01|Pq);
	for(i = 0; i < 64; i++ )
	{   
		if(Pq){
			WriteWord(CHROM_Quant[IZgzgIndex[i]]);
		}
		else{
			WriteByte(CHROM_Quant[IZgzgIndex[i]]);
		}
	}
	
    }

    void WriteHuffman_AC()
    {   
	int accum = 0;
	int i;

	for(i = 1; i <= 16; i++ )
	{   
	    WriteByte(ACXhuff_bits[i]);
	    accum += ACXhuff_bits[i];
	}
	for(i = 0; i < accum; i++ )
	{   
	    WriteByte(ACXhuff_huffval[i]);
	}
    }

    void WriteHuffman_DC()
    {   
	int accum = 0;
	int i;

	for(i = 1; i <= 16; i++ )
	{   
	    WriteByte(DCXhuff_bits[i]);
	    accum += DCXhuff_bits[i];
	}
	for(i = 0; i < accum; i++ )
	{   
	    WriteByte(DCXhuff_huffval[i]);
	}
    }


    void CHROM_WriteHuffman_AC()
    {   
	int accum = 0;
	int i;

	for(i = 1; i <= 16; i++ )
	{   
	    WriteByte(CHROM_ACXhuff_bits[i]);
	    accum += CHROM_ACXhuff_bits[i];
	}
	for(i = 0; i < accum; i++ )
	{   
	    WriteByte(CHROM_ACXhuff_huffval[i]);
	}
    }

    void CHROM_WriteHuffman_DC()
    {   
	int accum = 0;
	int i;

	for(i = 1; i <= 16; i++ )
	{   
	    WriteByte(CHROM_DCXhuff_bits[i]);
	    accum += CHROM_DCXhuff_bits[i];
	}
	for(i = 0; i < accum; i++ )
	{   
	    WriteByte(CHROM_DCXhuff_huffval[i]);
	}
    }


    void WriteDHT()
    {   
#if 0
	int end_p;
	int start_p;

	WriteMarker(196);
	start_p = ofp_ptr;
	WriteWord(0);
	WriteByte(0);
	WriteHuffman_DC();
	WriteByte(16);
	WriteHuffman_AC();
	end_p = ofp_ptr;
	ofp_ptr = start_p;
	WriteWord(end_p - start_p);
	ofp_ptr = end_p;
#endif

	//int end_p;
	int start_p;

	WriteMarker(196);
	start_p = ofp_ptr;
	WriteWord(0x1a2);

	WriteByte(0);
	WriteHuffman_DC();
	WriteByte(16);
	WriteHuffman_AC();

	WriteByte(1);
	CHROM_WriteHuffman_DC();
	WriteByte(17);
	CHROM_WriteHuffman_AC();

    }

    void WriteSOF()
    {   
#if 0
	int end_p;
	int start_p;

	WriteMarker(192);
	start_p = ofp_ptr;
	WriteWord(0);
	WriteByte(8);
	WriteWord(imageheight);
	WriteWord(imagewidth);
	WriteByte(1);
	WriteByte(1);
	WriteByte(17);
	WriteByte(0);
	end_p = ofp_ptr;
	ofp_ptr = start_p;
	WriteWord(end_p - start_p);
	ofp_ptr = end_p;
#endif

	//int end_p;
	//int start_p;

	WriteMarker(192);
	WriteWord(17);
	WriteByte(8);
//printf("H = %d \n", imageHeight);
	WriteWord(HEIGHT);
	WriteWord(WIDTH);
	WriteByte(3);
	WriteByte(1);
	WriteByte(17);
	WriteByte(0);

	WriteByte(2);
	WriteByte(17);
	WriteByte(1);

	WriteByte(3);
	WriteByte(17);
	WriteByte(1);
    }

    void WriteSOS()
    {   
#if 0
	int end_p;
	int start_p;

	WriteMarker(218);
	start_p = ofp_ptr;
	WriteWord(0);
	WriteByte(1);
	WriteByte(1);
	WriteByte(0);
	WriteByte(0);
	WriteByte(63);
	WriteByte(0);
	end_p = ofp_ptr;
	ofp_ptr = start_p;
	WriteWord(end_p - start_p);
	ofp_ptr = end_p;
#endif
	//int end_p;
	int start_p;

	WriteMarker(218);
	start_p = ofp_ptr;
	WriteWord(12);
	WriteByte(3);
	WriteByte(1);
	WriteByte(0);
	WriteByte(2);
	WriteByte(17);
	WriteByte(3);
	WriteByte(17);
	WriteByte(0);
	WriteByte(63);
	WriteByte(0);
	
    }

//  void FileWrite()	// DUT must not write to files!
//  {   		// (moved this to Monitor)
//	struct _IO_FILE *f;
//
//	f = fopen("test.jpg", "wb");
//	fwrite(ofp, sizeof(char), 2000, f);
//	fclose(f);
//	printf("Encoded JPEG file written successfully!\n");
//  }
 
    void main(void)
    {   
	int num_mdu;
	
	int n, i, k = 0;
	//int pics = 1, j = 0, k = 0, h = 0, m = 0;
	bytes bb;
	

	 if (iter == 0)
	    {   
		imageheight = imageHeight;
		imagewidth = imageWidth;
		JpegDefaultHuffman();
		WriteMarker(216);
		WriteAPP0();
		WriteDQT();
		WriteDHT();
		WriteSOF();
		WriteSOS();
		num_mdu = ((imageheight + 7) >> 3) * ((imagewidth + 7) >> 3);
	    }

	while(1)
	{   

	if(iter % (NUMENCODERS * NUMBLOCKS) == 0){
	
		Port1.receive(&in_blocks[0]);
		Port2.receive(&in_blocks[1]);
		Port3.receive(&in_blocks[2]);
		printf("finish huffman encoding %d blocks\n", iter);
	   }

	    do
	   {

	    	
		if(iter % NUMENCODERS == 0){
			input = &in_blocks[0][(iter/NUMENCODERS)%NUMBLOCKS*64];
			EncodeDC();
	    		EncodeAC();
		}
		if(iter % NUMENCODERS == 1){
			input = &in_blocks[1][(iter/NUMENCODERS)%NUMBLOCKS*64];
			EncodeDC_Cb();
			CHROM_EncodeAC();
		}
		if(iter % NUMENCODERS == 2){
			input = &in_blocks[2][(iter/NUMENCODERS)%NUMBLOCKS*64];
			EncodeDC_Cr();
			CHROM_EncodeAC();
		}  

	    n = ofp_ptr - ofp_ptr_pre;

	    if(n + k > 512)
	    {
		bb.n = k;
		PortOut.send(bb);
		k = 0;
	    }
	    //printf("Huffman sends %d bytes. ofp_ptr_pre = %d\n", n, ofp_ptr_pre);
	   // bb.n = n;
	    for(i=0; i<n; i++)
	    {
		bb.b[k ++] = ofp[ofp_ptr_pre++];
		if(k % 512 == 0)
		{
			bb.n = 512;

			//if(i == n - 1 && iter == NUMPICS * 3 - 1){
			//	bb.n |= 0x400;
			//}

			PortOut.send(bb);
			k = 0;
		}		
	    }
	    //printf("Huffman sends %d bytes. ofp_ptr_pre = %d, iter = %d\n", n, ofp_ptr_pre, iter);

	    
            //if((bb.n>>10 == 0) && iter == NUMPICS * 3 - 1)
	    if(iter == NUMPICS * 3 - 1)
	    {
		bb.n |= 0x400;
		//exit(0);
		PortOut.send(bb);
	    }
	    iter++ ;
	
	  }while((iter %  (NUMENCODERS * NUMBLOCKS)) != 0);

	  waitfor WAITFORHUFF;
       }
    }
};

behavior Encoder(i_blocks_receiver Port1,
	i_blocks_sender Port2
)
{
	int block0[64];
	int block1[64];
	int block2[64];
	int in_blocks[NUMBLOCKS*64];
	int out_blocks[NUMBLOCKS*64];
	int i;

    	ChenDCT1 dct1(in_blocks, block0);
    	ChenDCT2 dct2(block0, block1);
    	Quantize quan(block1, block2);
    	Zigzag   zigz(block2, out_blocks);

	void main()
	{
		while(1)
		{
			Port1.receive( &in_blocks);
			for(i = 0; i < NUMBLOCKS; i ++)
			{
				dct1.main();
				dct2.main();
				quan.main();
				zigz.main();
				//printf("%d th frame \n", i);
			}
			waitfor WAITFORENC;
			printf("Encoder frame %d sending\n", i);
			Port2.send( out_blocks);
			printf("Encoder frame %d ending\n", i);
		}
	}
    
};

behavior CHROM_Encoder(i_blocks_receiver Port1,
	i_blocks_sender Port2
)
{
	int block0[64];
	int block1[64];
	int block2[64];
	int in_blocks[NUMBLOCKS*64];
	int out_blocks[NUMBLOCKS*64];
	int i;

    	ChenDCT1 dct1(in_blocks, block0);
    	ChenDCT2 dct2(block0, block1);
    	CHROM_Quantize quan(block1, block2);
    	Zigzag   zigz(block2, out_blocks);

	void main()
	{
		while(1)
		{
			Port1.receive( &in_blocks);
			for(i = 0; i < NUMBLOCKS; i ++)
			{
				dct1.main();
				dct2.main();
				quan.main();
				zigz.main();
			}
			waitfor WAITFORENC;
			printf("CHROM_Encoder frame %d sending\n", i);
			Port2.send( out_blocks);
			printf("CHROM_Encoder frame %d ending\n", i);
		}
	}
    
};

behavior DUT(
    i_blocks_receiver pin1,
    i_blocks_receiver pin2,
    i_blocks_receiver pin3,
    i_bytes_sender PortOut)
{
    c_blocks_double_handshake cout1;
    c_blocks_double_handshake cout2;
    c_blocks_double_handshake cout3;
    //c_blocks_queue cout1(QUEUE_SIZE);
    //c_blocks_queue cout2(QUEUE_SIZE);
    //c_blocks_queue cout3(QUEUE_SIZE);

    Encoder enc1(pin1, cout1);
    CHROM_Encoder enc2(pin2, cout2);
    CHROM_Encoder enc3(pin3, cout3);
    Huffman  huff(cout1, cout2, cout3, PortOut);


    void main(void)
    {   
	par
	{   
		enc1.main();
		enc2.main();
		enc3.main();
		huff.main();
	}
    }
};

behavior Monitor(
    i_bytes_receiver Port
    )
{
    void main(void)
    {   
	FILE *f, *f2;
	//unsigned char gold;
	//int i, pics, j, numconflicts = 0;
	bytes bb;
	//int iter;
	sim_time t;
	//sim_time t2;
	sim_time_string buf;	// bug fix 11/11/08, RD
	//sim_time_string buf2;

	if (!(f = fopen("golden.jpg", "rb")))
	{   
	    printf("Cannot open file \"golden.jpg\" for reading.\n");
	    exit(10);
	}
	if (!(f2 = fopen("test.jpg", "wb")))
	{   
	    printf("Cannot open file \"test.jpg\" for writing.\n");
	    fclose(f);
	    exit(10);
	}

	while(1)
	{
	    Port.receive(&bb);
	    if(bb.n & 0x400)
	    {
	    	fwrite(bb.b, sizeof(char), (bb.n & 0x3ff), f2);
		fputc(0xff, f2);
		fputc(0xd9, f2);
		//fwrite(dataout, sizeof(char), dataLength, fout);
		//printf("zerocnt = %d dataLength = %d\n", zerocnt, dataLength);
		break;
	    }
	    else{
		fwrite(bb.b, sizeof(char), bb.n, f2);
	    }
	   
	}

	fclose(f);
	fclose(f2);
	t = now() / TIME_BASE;
	printf("%8s: Monitor exits simulation.\n", time2str(buf,t));

#ifdef OOOSIM
	numconflicts = 0;
	printf("OoONumIssues = %d \n", OoONumIssues);
	printf("TotalNumIssues = %d \n", TotalNumIssues);
	for(i = 0; i < OoOSimTotalSegments; i ++)
		{
			for(j = 0; j < OoOSimTotalSegments; j ++)
			{
				if(conflictTable[i* OoOSimTotalSegments + j])		
					numconflicts += 1;
			}
		}
	printf("numconflicts in cTable = %d \n", numconflicts);
#endif
	exit(0);
    }
};



behavior DataIn(	// new: virtual HW for data input
    i_blocks_receiver p1,
    i_blocks_sender   p2)
{
	int i = 0;
    void main(void)
    {
	blocks	b;

	while(1)
	{
	    p1.receive(&b);
		//printf("get %d th frame \n", i++);
	    p2.send(b);
		//printf("send %d th frame \n", i++);
	}
    }
};

behavior DataOut(	// new: virtual HW for data output
    i_bytes_receiver p1,
    i_bytes_sender   p2)
{
    void main(void)
    {
	bytes	b;

	while(1)
	{
	    p1.receive(&b);
	    p2.send(b);
	}
    }
};

behavior Platform(	// new: platform with DUT and I/O units
    i_blocks_receiver pin1,
    i_blocks_receiver pin2,
    i_blocks_receiver pin3,
    i_bytes_sender   pout)
{
    c_blocks_double_handshake cin1;
    c_blocks_double_handshake cin2;
    c_blocks_double_handshake cin3;
    c_bytes_queue cout(100ul);	

    DUT     dut(cin1, cin2, cin3, cout);
    DataOut dataout(cout, pout);
    DataIn  datain1(pin1, cin1);
    DataIn  datain2(pin2, cin2);
    DataIn  datain3(pin3, cin3);	
    void main(void)
    {
	par
	{
	    dut.main();
	    dataout.main();
	    datain1.main();
	    datain2.main();
	    datain3.main();
	}
    }
};

behavior Main()
{
    sim_time TimeStamp[180 * NUMPICS];
   
    c_blocks_double_handshake cin1;
    c_blocks_double_handshake cin2;
    c_blocks_double_handshake cin3;
    c_bytes_queue cout(100ul);
    Stimulus stimulus(cin1, cin2, cin3);
    Platform     jpegencoder(cin1, cin2, cin3, cout);
    Monitor  monitor(cout);

    int main(int argc, char **argv)
    {   

#ifdef OOOSIM
	//	conflictTable = cTable;
	//	nextTimeTable = ntTable;
	//	nextDeltaTable = ndTable;
	//	OoOSimTotalSegments = totalSegments;
	//	notifyTable = nTable;
#endif
	if(argc != 2){
		printf("wrong file name, *.bmp is expected !\n");
		exit (0);
	}
	else{
		fname = argv[1];
	}
	par
	{   
	    stimulus.main();
	    jpegencoder.main();
	    monitor.main();
	}
	return 0;
    }
};

//note _SCCPS_SIM = {true};
//note Main._SCCPS_SIM = {true};

//////////////////////////////////////////////////////////////////////
// End of file JpegPlatform.sc
//////////////////////////////////////////////////////////////////////
